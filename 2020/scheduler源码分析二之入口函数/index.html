<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Yuxiaobo">
  
  
  
  <link rel="prev" href="https://yuxiaobo96.github.io/2020/scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80%E4%B9%8B%E4%B8%BB%E7%BA%BF%E9%80%BB%E8%BE%91/" />
  
  <link rel="canonical" href="https://yuxiaobo96.github.io/2020/scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C%E4%B9%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Scheduler源码分析二之入口函数 | 将夜泊行
       
  </title>
  <meta name="title" content="Scheduler源码分析二之入口函数 | 将夜泊行">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/yuxiaobo96.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "Scheduler源码分析二之入口函数",
    "headline" : "Scheduler源码分析二之入口函数",
    "description" : "kube-scheduler 源码分析之入口函数 scheduler的源码主要存放在两个文件夹下： \/cmd\/kube-scheduler\/，是scheduler的入口函数",
    "inLanguage" : "zh-cn",
    "author" : "Yuxiaobo",
    "creator" : "Yuxiaobo",
    "publisher": "Yuxiaobo",
    "accountablePerson" : "Yuxiaobo",
    "copyrightHolder" : "Yuxiaobo",
    "copyrightYear" : "2020",
    "datePublished": "2020-01-06 17:14:26 \x2b0800 CST",
    "dateModified" : "2020-01-06 17:14:26 \x2b0800 CST",
    "url" : "https:\/\/yuxiaobo96.github.io\/2020\/scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C%E4%B9%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0\/",
    "wordCount" : "4098",
    "keywords" : [  "将夜泊行"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
        
        <div class="top-scroll-bar"></div>
    
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://yuxiaobo96.github.io/">将夜泊行</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
        
        <div class="top-scroll-bar"></div>
    
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://yuxiaobo96.github.io/">将夜泊行</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Scheduler源码分析二之入口函数</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://yuxiaobo96.github.io/" rel="author">Yuxiaobo</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-01-06 itemprop="datePublished">January 6, 2020</time>
                </span>
                in
                
                <span class="post-word-count">, 4098 words</span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h2 id="kube-scheduler-源码分析之入口函数">kube-scheduler 源码分析之入口函数</h2>

<p>scheduler的源码主要存放在两个文件夹下：</p>

<p><code>/cmd/kube-scheduler/</code>，是scheduler的入口函数，文件结构如下：</p>

<pre><code class="language-shell">kube-scheduler
├── app          # 该目录下包含运行scheduler时所需要的配置对象和参数
│   ├── BUILD
│   ├── config           # 包含配置对象及上下文内容
│   │   ├── BUILD
│   │   └── config.go
│   ├── options         # 包含scheduler运行时需要的参数
│   │   ├── BUILD
│   │   ├── configfile.go
│   │   ├── deprecated.go
│   │   ├── deprecated_test.go
│   │   ├── insecure_serving.go
│   │   ├── insecure_serving_test.go
│   │   ├── options.go
│   │   └── options_test.go
│   ├── server.go       # 读取默认配置文件，并初始化
│   └── testing
│       ├── BUILD
│       └── testserver.go
├── BUILD
├── OWNERS
└── scheduler.go     # main入口函数
</code></pre>

<h2 id="1-main-入口函数">1. main 入口函数</h2>

<blockquote>
<p>代码在<code>/cmd/kube-scheduler/scheduler.go</code></p>
</blockquote>

<pre><code class="language-go">func main() {
	rand.Seed(time.Now().UnixNano())

	command := app.NewSchedulerCommand()

	// TODO: once we switch everything over to Cobra commands, we can go back to calling
	// utilflag.InitFlags() (by removing its pflag.Parse() call). For now, we have to set the
	// normalize func and add the go flag set by hand.
	pflag.CommandLine.SetNormalizeFunc(cliflag.WordSepNormalizeFunc)
	// utilflag.InitFlags()
	logs.InitLogs()
	defer logs.FlushLogs()

	if err := command.Execute(); err != nil {
		os.Exit(1)
	}
}
</code></pre>

<p>这里使用命令行框架cobra，创建scheduler的命令对象并对命令参数进行校验。
scheduler组件代码通过cobra生成根命令和子命令来执行命令，使用 <code>cmd.Flags()</code>设置命令参数，通过调用 <code>command.Execute()</code>检验命令参数并执行。有关cobra的更多信息，请参阅<a href="https://github.com/spf13/cobra" rel="nofollow noreferrer" target="_blank">cobra</a>。</p>

<p>核心代码：</p>

<pre><code class="language-go">// 1.1 使用默认的参数和配置初始化scheduler结构体
command := app.NewSchedulerCommand()
// 执行Execute，这是cobra提供的执行命令的方法（在scheduler组件的调度逻辑完成后，最后执行）
if err := command.Execute(); err != nil {
		os.Exit(1)
	}
</code></pre>

<h2 id="1-1-newschedulercommand">1.1 NewSchedulerCommand()</h2>

<blockquote>
<p>代码在<code>/cmd/kube-scheduler/app/server.go</code></p>
</blockquote>

<p>NewSchedulerCommand用来初始化scheduler配置并创建SchedulerCommand对象</p>

<pre><code class="language-go">// NewSchedulerCommand creates a *cobra.Command object with default parameters and registryOptions
func NewSchedulerCommand(registryOptions ...Option) *cobra.Command {
	opts, err := options.NewOptions()
	if err != nil {
		klog.Fatalf(&quot;unable to initialize command options: %v&quot;, err)
	}

// 为scheduler创建 cobra.Command对象，即根命令
	cmd := &amp;cobra.Command{
		Use: &quot;kube-scheduler&quot;,
		Long: `The Kubernetes scheduler is a policy-rich, topology-aware,
workload-specific function that significantly impacts availability, performance,
and capacity. The scheduler needs to take into account individual and collective
resource requirements, quality of service requirements, hardware/software/policy
constraints, affinity and anti-affinity specifications, data locality, inter-workload
interference, deadlines, and so on. Workload-specific requirements will be exposed
through the API as necessary.`,
		Run: func(cmd *cobra.Command, args []string) {
			if err := runCommand(cmd, args, opts, registryOptions...); err != nil {
				fmt.Fprintf(os.Stderr, &quot;%v\n&quot;, err)
				os.Exit(1)
			}
		},
	}
	fs := cmd.Flags()
	namedFlagSets := opts.Flags()
	verflag.AddFlags(namedFlagSets.FlagSet(&quot;global&quot;))
	globalflag.AddGlobalFlags(namedFlagSets.FlagSet(&quot;global&quot;), cmd.Name())
	for _, f := range namedFlagSets.FlagSets {
		fs.AddFlagSet(f)
	}

	usageFmt := &quot;Usage:\n  %s\n&quot;
	cols, _, _ := term.TerminalSize(cmd.OutOrStdout())
	cmd.SetUsageFunc(func(cmd *cobra.Command) error {
		fmt.Fprintf(cmd.OutOrStderr(), usageFmt, cmd.UseLine())
		cliflag.PrintSections(cmd.OutOrStderr(), namedFlagSets, cols)
		return nil
	})
	cmd.SetHelpFunc(func(cmd *cobra.Command, args []string) {
		fmt.Fprintf(cmd.OutOrStdout(), &quot;%s\n\n&quot;+usageFmt, cmd.Long, cmd.UseLine())
		cliflag.PrintSections(cmd.OutOrStdout(), namedFlagSets, cols)
	})
	cmd.MarkFlagFilename(&quot;config&quot;, &quot;yaml&quot;, &quot;yml&quot;, &quot;json&quot;)

	return cmd
}
</code></pre>

<p>核心代码</p>

<pre><code class="language-go">// 1.1.1 NewOptions 构建并初始化scheduler需要的参数
opts, err := options.NewOptions()
// 1.1.2 完成配置的初始化，最后调用 Run()函数，
err := runCommand
</code></pre>

<h2 id="1-1-1-newoptions">1.1.1 NewOptions</h2>

<blockquote>
<p>代码在<code>/cmd/kube-scheduler/app/options/options.go</code></p>
</blockquote>

<p>NewOptions用来配置SchedulerServer需要的参数和配置，核心参数为<code>KubeSchedulerConfiguration</code>结构体（代码在<code>/pkg/scheduler/apis/config/types.go</code> ）</p>

<p>NewOptions的代码：</p>

<pre><code class="language-go">// NewOptions returns default scheduler app options.
func NewOptions() (*Options, error) {
	cfg, err := newDefaultComponentConfig()
	if err != nil {
		return nil, err
	}

	hhost, hport, err := splitHostIntPort(cfg.HealthzBindAddress)
	if err != nil {
		return nil, err
	}

	o := &amp;Options{
		ComponentConfig: *cfg,
		SecureServing:   apiserveroptions.NewSecureServingOptions().WithLoopback(),
		CombinedInsecureServing: &amp;CombinedInsecureServingOptions{
			Healthz: (&amp;apiserveroptions.DeprecatedInsecureServingOptions{
				BindNetwork: &quot;tcp&quot;,
			}).WithLoopback(),
			Metrics: (&amp;apiserveroptions.DeprecatedInsecureServingOptions{
				BindNetwork: &quot;tcp&quot;,
			}).WithLoopback(),
			BindPort:    hport,
			BindAddress: hhost,
		},
		Authentication: apiserveroptions.NewDelegatingAuthenticationOptions(),
		Authorization:  apiserveroptions.NewDelegatingAuthorizationOptions(),
		Deprecated: &amp;DeprecatedOptions{
			UseLegacyPolicyConfig:    false,
			PolicyConfigMapNamespace: metav1.NamespaceSystem,
		},
	}

	o.Authentication.TolerateInClusterLookupFailure = true
	o.Authentication.RemoteKubeConfigFileOptional = true
	o.Authorization.RemoteKubeConfigFileOptional = true
	o.Authorization.AlwaysAllowPaths = []string{&quot;/healthz&quot;}

	// Set the PairName but leave certificate directory blank to generate in-memory by default
	o.SecureServing.ServerCert.CertDirectory = &quot;&quot;
	o.SecureServing.ServerCert.PairName = &quot;kube-scheduler&quot;
	o.SecureServing.BindPort = ports.KubeSchedulerPort

	return o, nil
}
</code></pre>

<p>在第3行中的<code>newDefaultComponentConfig()</code>点进去就会发现调用的是<code>KubeSchedulerConfiguration</code>结构体</p>

<h2 id="1-1-2-runcommand">1.1.2 runCommand</h2>

<blockquote>
<p>代码在<code>/cmd/kube-scheduler/app/server.go</code></p>
</blockquote>

<p>代码如下：</p>

<pre><code class="language-go">// runCommand runs the scheduler.
func runCommand(cmd *cobra.Command, args []string, opts *options.Options, registryOptions ...Option) error {
	verflag.PrintAndExitIfRequested()
	utilflag.PrintFlags(cmd.Flags())

	if len(args) != 0 {
		fmt.Fprint(os.Stderr, &quot;arguments are not supported\n&quot;)
	}

	if errs := opts.Validate(); len(errs) &gt; 0 {
		return utilerrors.NewAggregate(errs)
	}

	if len(opts.WriteConfigTo) &gt; 0 {
		c := &amp;schedulerserverconfig.Config{}
		if err := opts.ApplyTo(c); err != nil {
			return err
		}
		if err := options.WriteConfigFile(opts.WriteConfigTo, &amp;c.ComponentConfig); err != nil {
			return err
		}
		klog.Infof(&quot;Wrote configuration to: %s\n&quot;, opts.WriteConfigTo)
		return nil
	}

	c, err := opts.Config()
	if err != nil {
		return err
	}

	// Get the completed config
	cc := c.Complete()

	// Apply algorithms based on feature gates.
	// TODO: make configurable?
	algorithmprovider.ApplyFeatureGates()

	// Configz registration.
	if cz, err := configz.New(&quot;componentconfig&quot;); err == nil {
		cz.Set(cc.ComponentConfig)
	} else {
		return fmt.Errorf(&quot;unable to register configz: %s&quot;, err)
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	return Run(ctx, cc, registryOptions...)
}
</code></pre>

<p>第10行，<code>errs := opts.Validate()</code>校验标题1.1.1中提到的options参数</p>

<p>代码如下：</p>

<pre><code class="language-go">/ Validate validates all the required options.
func (o *Options) Validate() []error {
	var errs []error

	if err := validation.ValidateKubeSchedulerConfiguration(&amp;o.ComponentConfig).ToAggregate(); err != nil {
		errs = append(errs, err.Errors()...)
	}
	errs = append(errs, o.SecureServing.Validate()...)
	errs = append(errs, o.CombinedInsecureServing.Validate()...)
	errs = append(errs, o.Authentication.Validate()...)
	errs = append(errs, o.Authorization.Validate()...)
	errs = append(errs, o.Deprecated.Validate()...)

	return errs
}
</code></pre>

<p>第26行，<code>c, err := opts.Config()</code>初始化scheduler的config对象</p>

<p>config的具体代码如下：</p>

<pre><code class="language-go">// Config return a scheduler config object
func (o *Options) Config() (*schedulerappconfig.Config, error) {
	if o.SecureServing != nil {
		if err := o.SecureServing.MaybeDefaultWithSelfSignedCerts(&quot;localhost&quot;, nil, []net.IP{net.ParseIP(&quot;127.0.0.1&quot;)}); err != nil {
			return nil, fmt.Errorf(&quot;error creating self-signed certificates: %v&quot;, err)
		}
	}

	c := &amp;schedulerappconfig.Config{}
	if err := o.ApplyTo(c); err != nil {
		return nil, err
	}

	// Prepare kube clients.
	client, leaderElectionClient, eventClient, err := createClients(c.ComponentConfig.ClientConnection, o.Master, c.ComponentConfig.LeaderElection.RenewDeadline.Duration)
	if err != nil {
		return nil, err
	}

	coreBroadcaster := record.NewBroadcaster()
	coreRecorder := coreBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: c.ComponentConfig.SchedulerName})

	// Set up leader election if enabled.
	var leaderElectionConfig *leaderelection.LeaderElectionConfig
	if c.ComponentConfig.LeaderElection.LeaderElect {
		leaderElectionConfig, err = makeLeaderElectionConfig(c.ComponentConfig.LeaderElection, leaderElectionClient, coreRecorder)
		if err != nil {
			return nil, err
		}
	}

	c.Client = client
	c.InformerFactory = informers.NewSharedInformerFactory(client, 0)
	c.PodInformer = scheduler.NewPodInformer(client, 0)
	c.EventClient = eventClient.EventsV1beta1()
	c.CoreEventClient = eventClient.CoreV1()
	c.CoreBroadcaster = coreBroadcaster
	c.LeaderElection = leaderElectionConfig

	return c, nil
}
</code></pre>

<p>其中主要执行以下操作：</p>

<ul>
<li>第15行：构建kube clients：client、leaderElectionClient、eventClient</li>
<li>第20行：创建event broadcaster</li>
<li>第24行：设置leader election（如果开启），用来对多个scheduler进行选举</li>
<li>第33行：创建informer对象，主要包括<code>NewSharedInformerFactory</code>和<code>NewPodInformer</code>函数</li>
</ul>

<p>第36行，<code>algorithmprovider.ApplyFeatureGates()</code>提供默认的算法，后面详细介绍</p>

<p>第48行，<code>return Run(ctx, cc, registryOptions...)</code>调用Run函数（启动程序），下面对 Run 函数详细介绍</p>

<h2 id="2-run">2. Run</h2>

<blockquote>
<p>代码在<code>/cmd/kube-scheduler/app/server.go</code></p>
</blockquote>

<p>在scheduler调度逻辑开始之前，Run函数将与scheduler相关的配置先运行起来</p>

<p>具体代码如下：</p>

<pre><code class="language-go">// Run executes the scheduler based on the given configuration. It only returns on error or when context is done.
func Run(ctx context.Context, cc schedulerserverconfig.CompletedConfig, outOfTreeRegistryOptions ...Option) error {
	// To help debugging, immediately log version
	klog.V(1).Infof(&quot;Starting Kubernetes Scheduler version %+v&quot;, version.Get())

	outOfTreeRegistry := make(framework.Registry)
	for _, option := range outOfTreeRegistryOptions {
		if err := option(outOfTreeRegistry); err != nil {
			return err
		}
	}

	// Prepare event clients.
	if _, err := cc.Client.Discovery().ServerResourcesForGroupVersion(eventsv1beta1.SchemeGroupVersion.String()); err == nil {
		cc.Broadcaster = events.NewBroadcaster(&amp;events.EventSinkImpl{Interface: cc.EventClient.Events(&quot;&quot;)})
		cc.Recorder = cc.Broadcaster.NewRecorder(scheme.Scheme, cc.ComponentConfig.SchedulerName)
	} else {
		recorder := cc.CoreBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: cc.ComponentConfig.SchedulerName})
		cc.Recorder = record.NewEventRecorderAdapter(recorder)
	}

	// Create the scheduler.
	sched, err := scheduler.New(cc.Client,
		cc.InformerFactory,
		cc.PodInformer,
		cc.Recorder,
		ctx.Done(),
		scheduler.WithName(cc.ComponentConfig.SchedulerName),
		scheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),
		scheduler.WithHardPodAffinitySymmetricWeight(cc.ComponentConfig.HardPodAffinitySymmetricWeight),
		scheduler.WithPreemptionDisabled(cc.ComponentConfig.DisablePreemption),
		scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),
		scheduler.WithBindTimeoutSeconds(cc.ComponentConfig.BindTimeoutSeconds),
		scheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),
		scheduler.WithFrameworkPlugins(cc.ComponentConfig.Plugins),
		scheduler.WithFrameworkPluginConfig(cc.ComponentConfig.PluginConfig),
		scheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),
		scheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),
	)
	if err != nil {
		return err
	}

	// Prepare the event broadcaster.
	if cc.Broadcaster != nil &amp;&amp; cc.EventClient != nil {
		cc.Broadcaster.StartRecordingToSink(ctx.Done())
	}
	if cc.CoreBroadcaster != nil &amp;&amp; cc.CoreEventClient != nil {
		cc.CoreBroadcaster.StartRecordingToSink(&amp;corev1.EventSinkImpl{Interface: cc.CoreEventClient.Events(&quot;&quot;)})
	}
	// Setup healthz checks.
	var checks []healthz.HealthChecker
	if cc.ComponentConfig.LeaderElection.LeaderElect {
		checks = append(checks, cc.LeaderElection.WatchDog)
	}

	// Start up the healthz server.
	if cc.InsecureServing != nil {
		separateMetrics := cc.InsecureMetricsServing != nil
		handler := buildHandlerChain(newHealthzHandler(&amp;cc.ComponentConfig, separateMetrics, checks...), nil, nil)
		if err := cc.InsecureServing.Serve(handler, 0, ctx.Done()); err != nil {
			return fmt.Errorf(&quot;failed to start healthz server: %v&quot;, err)
		}
	}
	if cc.InsecureMetricsServing != nil {
		handler := buildHandlerChain(newMetricsHandler(&amp;cc.ComponentConfig), nil, nil)
		if err := cc.InsecureMetricsServing.Serve(handler, 0, ctx.Done()); err != nil {
			return fmt.Errorf(&quot;failed to start metrics server: %v&quot;, err)
		}
	}
	if cc.SecureServing != nil {
		handler := buildHandlerChain(newHealthzHandler(&amp;cc.ComponentConfig, false, checks...), cc.Authentication.Authenticator, cc.Authorization.Authorizer)
		// TODO: handle stoppedCh returned by c.SecureServing.Serve
		if _, err := cc.SecureServing.Serve(handler, 0, ctx.Done()); err != nil {
			// fail early for secure handlers, removing the old error loop from above
			return fmt.Errorf(&quot;failed to start secure server: %v&quot;, err)
		}
	}

	// Start all informers.
	go cc.PodInformer.Informer().Run(ctx.Done())
	cc.InformerFactory.Start(ctx.Done())

	// Wait for all caches to sync before scheduling.
	cc.InformerFactory.WaitForCacheSync(ctx.Done())

	// If leader election is enabled, runCommand via LeaderElector until done and exit.
	if cc.LeaderElection != nil {
		cc.LeaderElection.Callbacks = leaderelection.LeaderCallbacks{
			OnStartedLeading: sched.Run,
			OnStoppedLeading: func() {
				klog.Fatalf(&quot;leaderelection lost&quot;)
			},
		}
		leaderElector, err := leaderelection.NewLeaderElector(*cc.LeaderElection)
		if err != nil {
			return fmt.Errorf(&quot;couldn't create leader elector: %v&quot;, err)
		}

		leaderElector.Run(ctx)

		return fmt.Errorf(&quot;lost lease&quot;)
	}

	// Leader election is disabled, so runCommand inline until done.
	sched.Run(ctx)
	return fmt.Errorf(&quot;finished without leader elect&quot;)
}
</code></pre>

<p>主要功能如下：</p>

<ul>
<li>运行event broadcaster、healthz checks、healthz server、metrics server(根据config构建一个metrics server)</li>
<li>创建scheduler结构体</li>
<li>启动所有的informer，并在调度前等待etcd中的资源数据同步到本地的store中</li>
<li>如果 leader election开启，并有多个scheduler，则进行选举，直到选举结束或退出(一般系统默认scheduler：default-scheduler)</li>
<li>运行<code>sched.Run</code>函数，执行scheduler的调度逻辑</li>
</ul>

<p>核心源码介绍：</p>

<h2 id="2-1-outoftreeregistry">2.1 outOfTreeRegistry</h2>

<p>第6行，创建Registry(注册表)，其中包含所有可用的plugins，并控制这些plugin的启动和初始化。</p>

<pre><code class="language-go">outOfTreeRegistry := make(framework.Registry)
	for _, option := range outOfTreeRegistryOptions {
		if err := option(outOfTreeRegistry); err != nil {
			return err
		}
	}
</code></pre>

<h2 id="2-1-1-registry">2.1.1 Registry</h2>

<blockquote>
<p>代码在<code>/pkg/scheduler/framework/v1alpha1/registry.go</code></p>
</blockquote>

<p>代码如下：</p>

<pre><code class="language-go">// PluginFactory is a function that builds a plugin.
type PluginFactory = func(configuration *runtime.Unknown, f FrameworkHandle) (Plugin, error)

// DecodeInto decodes configuration whose type is *runtime.Unknown to the interface into.
func DecodeInto(configuration *runtime.Unknown, into interface{}) error {
	if configuration == nil || configuration.Raw == nil {
		return nil
	}

	switch configuration.ContentType {
	// If ContentType is empty, it means ContentTypeJSON by default.
	case runtime.ContentTypeJSON, &quot;&quot;:
		return json.Unmarshal(configuration.Raw, into)
	case runtime.ContentTypeYAML:
		return yaml.Unmarshal(configuration.Raw, into)
	default:
		return fmt.Errorf(&quot;not supported content type %s&quot;, configuration.ContentType)
	}
}

// Registry is a collection of all available plugins. The framework uses a
// registry to enable and initialize configured plugins.
// All plugins must be in the registry before initializing the framework.
type Registry map[string]PluginFactory

// Register adds a new plugin to the registry. If a plugin with the same name
// exists, it returns an error.
func (r Registry) Register(name string, factory PluginFactory) error {
	if _, ok := r[name]; ok {
		return fmt.Errorf(&quot;a plugin named %v already exists&quot;, name)
	}
	r[name] = factory
	return nil
}

// Unregister removes an existing plugin from the registry. If no plugin with
// the provided name exists, it returns an error.
func (r Registry) Unregister(name string) error {
	if _, ok := r[name]; !ok {
		return fmt.Errorf(&quot;no plugin named %v exists&quot;, name)
	}
	delete(r, name)
	return nil
}

// Merge merges the provided registry to the current one.
func (r Registry) Merge(in Registry) error {
	for name, factory := range in {
		if err := r.Register(name, factory); err != nil {
			return err
		}
	}
	return nil
}
</code></pre>

<p>注释讲解很清晰，不再赘述。</p>

<h2 id="2-2-scheduler-new">2.2 scheduler.New</h2>

<p>第22行，创建scheduler结构体，其中包含scheduler调度逻辑执行过程中需要的所有参数和配置。</p>

<pre><code class="language-go">	// Create the scheduler.
	sched, err := scheduler.New(cc.Client,
		cc.InformerFactory,
		cc.PodInformer,
		cc.Recorder,
		ctx.Done(),
		scheduler.WithName(cc.ComponentConfig.SchedulerName),
		scheduler.WithAlgorithmSource(cc.ComponentConfig.AlgorithmSource),
		scheduler.WithHardPodAffinitySymmetricWeight(cc.ComponentConfig.HardPodAffinitySymmetricWeight),
		scheduler.WithPreemptionDisabled(cc.ComponentConfig.DisablePreemption),
		scheduler.WithPercentageOfNodesToScore(cc.ComponentConfig.PercentageOfNodesToScore),
		scheduler.WithBindTimeoutSeconds(cc.ComponentConfig.BindTimeoutSeconds),
		scheduler.WithFrameworkOutOfTreeRegistry(outOfTreeRegistry),
		scheduler.WithFrameworkPlugins(cc.ComponentConfig.Plugins),
		scheduler.WithFrameworkPluginConfig(cc.ComponentConfig.PluginConfig),
		scheduler.WithPodMaxBackoffSeconds(cc.ComponentConfig.PodMaxBackoffSeconds),
		scheduler.WithPodInitialBackoffSeconds(cc.ComponentConfig.PodInitialBackoffSeconds),
	)
</code></pre>

<p>其中：</p>

<ul>
<li><p>第3行，<code>cc.InformerFactory</code>调用的是<code>SharedInformerFactory</code>接口：Shared 指的是在多个 Informer 中共享一个本地 cache。</p></li>

<li><p>第4行，<code>cc.PodInformer</code>调用的是<code>PodInformer</code>接口：基于SharedInformer的监听pod，并根据index来管理pod（当事件类型为add时，将其保存到本地缓存store中，并创建索引；当事件类型为delete时，则在本地缓存中删除此对象）</p></li>

<li><p>第5行，<code>cc.Recorder</code>调用的是<code>EventRecorder</code>接口：用来record events</p></li>

<li><p>第6行，<code>ctx.Done()</code>调用的是<code>Context</code>接口：使用一个 Done channel</p></li>

<li><p>从第7行开始到最后，调用的是<code>cc.ComponentConfig</code>中的参数，即是<code>KubeSchedulerConfiguration</code>结构体：用来配置scheduler</p></li>
</ul>

<h2 id="2-3-informerfactory-start">2.3 InformerFactory.Start</h2>

<p>第80行，启动所有informers，包括PodInformer、InformerFactory，主要涉及到informer，请参阅<a href="https://github.com/kube-incubator/kube-explorer/blob/master/content/kube-scheduler/informer.md" rel="nofollow noreferrer" target="_blank">informer机制</a></p>

<pre><code class="language-go">	// Start all informers.
	go cc.PodInformer.Informer().Run(ctx.Done())
	cc.InformerFactory.Start(ctx.Done())
</code></pre>

<h2 id="2-4-waitforcachesync">2.4 WaitForCacheSync</h2>

<p>第84行，在调度逻辑执行前，需等到所有的caches同步</p>

<pre><code class="language-go">	// Wait for all caches to sync before scheduling.
	cc.InformerFactory.WaitForCacheSync(ctx.Done())
</code></pre>

<p>在这一步，涉及到reflector(反射器)、apiserver、etcd、store等的关系，一并在<a href="https://github.com/kube-incubator/kube-explorer/blob/master/content/kube-scheduler/informer.md" rel="nofollow noreferrer" target="_blank">informer机制</a>中讲解</p>

<h2 id="2-5-sched-run">2.5 sched.Run</h2>

<p>第106行，等待cache同步完成后，开始执行调度逻辑。</p>

<pre><code class="language-go">	sched.Run(ctx)
</code></pre>

<p>Run函数的具体代码如下：</p>

<blockquote>
<p>代码在<code>/pkg/scheduler/scheduler.go</code></p>
</blockquote>

<pre><code class="language-go">// Run begins watching and scheduling. It waits for cache to be synced, then starts scheduling and blocked until the context is done.
func (sched *Scheduler) Run(ctx context.Context) {
	if !cache.WaitForCacheSync(ctx.Done(), sched.scheduledPodsHasSynced) {
		return
	}
	sched.SchedulingQueue.Run()
	wait.UntilWithContext(ctx, sched.scheduleOne, 0)
	sched.SchedulingQueue.Close()
}
</code></pre>

<p>以上是从入口函数开始，到执行scheduler逻辑之前的源码分析，sched.Run的源码分析在下一节。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Yuxiaobo </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://yuxiaobo96.github.io/2020/scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C%E4%B9%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0/>https://yuxiaobo96.github.io/2020/scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BA%8C%E4%B9%8B%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0/</span>
            </p>
            
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://yuxiaobo96.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://yuxiaobo96.github.io/2020/scheduler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80%E4%B9%8B%E4%B8%BB%E7%BA%BF%E9%80%BB%E8%BE%91/" class="prev" rel="prev" title="Scheduler源码分析一之主线逻辑"><i class="iconfont icon-left"></i>&nbsp;Scheduler源码分析一之主线逻辑</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
        
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'cdf2110576d2e664531d',
    clientSecret: '6a6c277a187f8ecef693d89e334a942aee820a96',
    repo: 'yuxiaobo96.github.io',
    owner: 'yuxiaobo96',
    admin: ['yuxiaobo96'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://yuxiaobo96.github.io/">Yuxiaobo</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>













    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
